import{_ as t,o as e,c as a,Q as o}from"./chunks/framework.1a91c06a.js";const n="/img/merkleTree.png",s="/img/worldState.png",r="/img/accountState.png",i="/img/block.png",c="/img/mainDiagram.png",y=JSON.parse('{"title":"Ethereum Virtual Machine (EVM)","description":"","frontmatter":{"id":"evm-state","title":"Ethereum Virtual Machine (EVM)","head":[["meta",{"property":"og:title","content":"Ethereum Virtual Machine (EVM) | Lyfebloc Docs"}],["meta",{"property":"og:description","content":"Lyfebloc Network is a highly scalable modular blockchain powering dynamic applications with extensive full-stack adaptability."}]]},"headers":[],"relativePath":"concepts/evm-state.md","filePath":"concepts/evm-state.md","lastUpdated":1739729557000}'),h={name:"concepts/evm-state.md"},l=o('<h2 id="merkle-trees" tabindex="-1">Merkle Trees <a class="header-anchor" href="#merkle-trees" aria-label="Permalink to &quot;Merkle Trees&quot;">​</a></h2><p>Before discussing the main data objects in Ethereum, we need to go over what Merkle trees are, and what are the properties that make them useful.</p><p>A <strong>Merkle tree</strong> is a <em>tree</em> data structure, where the leaf nodes contain the hash of a block of data and the non-leaf nodes contain the hash of its children nodes.</p><p><img src="'+n+'" alt="Example Merkle tree"></p><p>In a Merkle tree, any change to the underlying data causes the hash of the node referring to the data to change. Since each parent node hash depends on the data of its children, any change to the data of a child node causes the parent hash to change. This happens to each parent node up to the root node. Therefore, any change to the data at the leaf nodes causes the root node hash to change. From this, we can derive two important properties:</p><ol><li>We don&#39;t need to compare all the data across the leaf nodes to know if they have the same data. We can just compare the root node hash.</li><li>If we want to prove that specific data is part of the tree, we can use a technique called Merkle proofs. We won&#39;t dive into details here but it is an easy and effective way to prove that a piece of data is in the Merkle tree.</li></ol><p>The first property is important because it makes it possible to store only a hash of the root node to represent the data at that point in time. This means we only need to store the root hash of the tree representing the block on the blockchain (as opposed to storing all the data in the blockchain) and still keep the data immutable.</p><h2 id="world-state" tabindex="-1">World State <a class="header-anchor" href="#world-state" aria-label="Permalink to &quot;World State&quot;">​</a></h2><p>The <strong>world state</strong> is a mapping between <strong>addresses</strong> (accounts) and <strong>account states</strong>.</p><p>The world state is not stored on the blockchain, but the Yellow Paper states it is expected that implementations store this data in a trie (also referred to as the state database or state trie). The world state can be seen as the global state that is constantly updated by transaction executions.</p><p>All the information about Ethereum accounts lives in the world state and is stored in the world state trie. If you want to know the balance of an account, or the current state of a smart contract, you query the world state trie to retrieve the account state of that account. We’ll describe how this data is stored shortly.</p><p><img src="'+s+'" alt="World State"></p><h2 id="account-state" tabindex="-1">Account State <a class="header-anchor" href="#account-state" aria-label="Permalink to &quot;Account State&quot;">​</a></h2><p>In Ethereum, there are two types of accounts: <strong>External Owned Accounts (EOA)</strong> and <strong>Contract Accounts</strong>.</p><p>An EOA account is an account that regular users have, that they can use to send Ether to one another and deploy smart contracts with.</p><p>A contract account is an account that is created when a smart contract is deployed. Every smart contract has its own Ethereum account.</p><p>The account state contains information about an Ethereum account. For example, it stores how much Ether an account has, and the number of transactions sent by the account. Each account has an <em><strong>account state</strong></em>.</p><p>Let&#39;s take a look into each one of the fields in the account state:</p><ul><li><strong>nonce</strong> - Number of transactions sent from this address (if this is an External Owned Account - EOA) or the number of contract creations made by this account</li><li><strong>balance</strong> - Total Ether (in Wei) owned by this account</li><li><strong>storageRoot</strong> - Hash of the root node of the account storage trie</li><li><strong>codeHash</strong> - For contract accounts, the hash of the EVM code of this account. For EOAs, this will be empty.</li></ul><p>One important detail about the account state is that all fields (except the codeHash) are <strong>mutable</strong>. For example, when one account sends some Ether to another, the nonce will be incremented, and the balance will be updated to reflect the new balance.</p><p>One of the consequences of the codeHash being immutable is that if you deploy a contract with a bug, you can&#39;t update the same contract. You need to deploy a new contract (the buggy version will be available forever). This is why it is important to use tools like Truffle to develop and test your smart contracts and follow the best practices when working with Solidity.</p><p>The Account Storage trie is where the data associated with an account is stored. This is only relevant for Contract Accounts, as for EOAs the storageRoot is <strong>empty</strong>, and the codeHash is the hash of an empty string.</p><p><img src="'+r+'" alt="Account State"></p><h2 id="transactions" tabindex="-1">Transactions <a class="header-anchor" href="#transactions" aria-label="Permalink to &quot;Transactions&quot;">​</a></h2><p>Transactions are what make the state change from the current state to the next state. In Ethereum, we have three types of transactions:</p><ol><li>Transactions that transfer value between two EOAs (e.g, change the sender and receiver account balances)</li><li>Transactions that send a message call to a contract (e.g, set a value in the smart contract by sending a message call that executes a setter method)</li><li>Transactions that deploy a contract (therefore, create an account, the contract account)</li></ol><div class="tip custom-block"><p class="custom-block-title">Clarification</p><p>Technically, <strong>1</strong> and <strong>2</strong> are the same - transactions that send message calls that affect an account state, either EOA or contract accounts.</p><p>It is easier to think about them as three different types.</p></div><p>These are the fields of a transaction:</p><ul><li><strong>nonce</strong> - Number of transactions sent by the account that created the transaction</li><li><strong>gasPrice</strong> - Value (in Wei) that will be paid per unit of gas for the computation costs of executing this transaction</li><li><strong>gasLimit</strong> - Maximum amount of gas to be used while executing this transaction</li><li><strong>to</strong><ul><li>If this transaction is transferring Ether, the address of the EOA account that will receive a value transfer</li><li>If this transaction is sending a message to a contract (e.g, calling a method in the smart contract), this is address of the contract</li><li>If this transaction is creating a contract, this value is always empty</li></ul></li><li><strong>value</strong><ul><li>If this transaction is transferring Ether, the amount in Wei that will be transferred to the recipient account</li><li>If this transaction is sending a message to a contract, the amount of Wei payable by the smart contract receiving the message</li><li>If this transaction is creating a contract, this is the amount of Wei that will be added to the balance of the created contract</li></ul></li><li><strong>v, r, s</strong> - Values used in the cryptographic signature of the transaction used to determine the sender of the transaction</li><li><strong>data</strong> (only for value transfer and sending a message call to a smart contract) -Input data of the message call ( e.g, imagine you are trying to execute a setter method in your smart contract, the data field would contain the identifier of the setter method, and the value that should be passed as a parameter)</li><li><strong>init</strong> (only for contract creation) - The EVM-code utilized for initialization of the contract</li></ul><p>Not surprisingly, all transactions in a block are stored in a trie. <br>The root hash of this trie is stored in the... block header! Let&#39;s take a look into the anatomy of an Ethereum block.</p><h2 id="blocks" tabindex="-1">Blocks <a class="header-anchor" href="#blocks" aria-label="Permalink to &quot;Blocks&quot;">​</a></h2><p>The block header is divided into two parts, the <strong>block header</strong> and the <strong>block body</strong>.</p><p>The block header is the blockchain part of Ethereum. This is the structure that contains the hash of its predecessor block (also known as parent block), building a cryptographically guaranteed chain.</p><p>The block body contains a list of transactions that have been included in this block, and a list of uncle (<em>ommer</em>) block headers.</p><p><img src="'+i+'" alt="Block Structure"></p><p>The block header contains the following fields:</p><ul><li><strong>parentHash</strong> - Hash of the block header from the previous block. Each block contains a hash of the previous block, all the way to the first block in the chain. This is how all the data is protected against modifications (any modification in a previous block would change the hash of all blocks after the modified block)</li><li><strong>ommersHash</strong> - Hash of the uncle blocks headers part of the block body</li><li><strong>beneficiary</strong> - Ethereum account that will get fees for mining this block</li><li><strong>stateRoot</strong> - Hash of the root node of the world state trie (after all transactions are executed)</li><li><strong>transactionsRoot</strong> - Hash of the root node of the transactions trie. This trie contains all transactions in the block body</li><li><strong>receiptsRoot</strong> - Every time a transaction is executed, Ethereum generates a transaction receipt that contains information about the transaction execution. This field is the hash of the root node of the transactions receipt trie</li><li><strong>logsBloom</strong> - Bloom filter that can be used to find out if logs were generated on transactions in this block (if you want more details check this Stack Overflow answer). This avoids storing logs in the block (saving a lot of space)</li><li><strong>difficulty</strong> - Difficulty level of this block. This is a measure of how hard it was to mine this block (I&#39;m not diving into the details of how this is calculated in this post)</li><li><strong>number</strong> - Number of ancestor blocks. This represents the height of the chain (how many blocks are in the chain). The genesis block has number zero</li><li><strong>gasLimit</strong> - Each transaction consumes gas. The gas limit specifies the maximum gas that can be used by the transactions included in the block. It is a way to limit the number of transactions in a block</li><li><strong>gasUsed</strong> - Sum of the gas cost of each transaction in the block</li><li><strong>timestamp</strong> - Unix timestamp when the block was created. Note that due to the decentralized nature of Ethereum, we can&#39;t trust in this value (especially when implementing smart contracts that have time-related business logic)</li><li><strong>extraData</strong> - Arbitrary byte array that can contain anything. When a miner is creating the block, it can choose to add anything in this field</li><li><strong>mixHash</strong> - Hash used to verify that a block has been mined properly (if you want to really understand this, read about the Ethash proof-of-work function)</li><li><strong>nonce</strong> - Same as the mixHash, this value is used to verify that a block has been mined properly</li></ul><h2 id="recap" tabindex="-1">Recap <a class="header-anchor" href="#recap" aria-label="Permalink to &quot;Recap&quot;">​</a></h2><p>Ethereum has 4 types of tries:</p><ol><li>The world state trie contains the mapping between addresses and account states. The hash of the root node of the world state trie is included in a block (in the stateRoot field) to represent the current state when that block was created. We only have one world state trie</li><li>The account storage trie contains the data associated with a smart contract. The hash of the root node of the Account storage trie is included in the account state (in the storageRoot field). We have one Account storage trie for each account</li><li>The transaction trie contains all the transactions included in a block. The hash of the root node of the Transaction trie is included in the block header (in the transactionsRoot field). We have one transaction trie per block</li><li>The transaction receipt trie contains all the transaction receipts for the transactions included in a block. The hash of the root node of the transaction receipts trie is included in also included in the block header (in the receiptsRoot field); We have one transaction receipts trie per block</li></ol><p>Objects covered:</p><ol><li><strong>World state</strong>: the hard drive of the distributed computer that is Ethereum. It is a mapping between addresses and account states</li><li><strong>Account state</strong>: stores the state of each one of Ethereum&#39;s accounts. It also contains the storageRoot of the account state trie, which contains the storage data for the account</li><li><strong>Transaction</strong>: represents a state transition in the system. It can be a funds transfer, a message call, or a contract deployment</li><li><strong>Block</strong>: contains the link to the previous block (parentHash) and contains a group of transactions that, when executed, will yield the new state of the system. It also contains the stateRoot, the transactionRoot and the receiptsRoot, the hash of the root nodes of the world state trie, the transaction trie, and the transaction receipts trie, respectively</li></ol><p><img src="'+c+'" alt="Main Diagram"></p><h2 id="credits" tabindex="-1">Credits <a class="header-anchor" href="#credits" aria-label="Permalink to &quot;Credits&quot;">​</a></h2><p>This clear and concise walkthrough of Ethereum&#39;s yellow paper was originally posted by Lucas Saldanha, on <a href="https://www.lucassaldanha.com/author/lucas-saldanha/" target="_blank" rel="noreferrer">his personal blog</a>.</p><h2 id="📜-resources" tabindex="-1">📜 Resources <a class="header-anchor" href="#📜-resources" aria-label="Permalink to &quot;📜 Resources&quot;">​</a></h2><ul><li><strong><a href="https://brilliant.org/wiki/merkle-tree/" target="_blank" rel="noreferrer">Merkle Trees</a></strong></li><li><strong><a href="https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5" target="_blank" rel="noreferrer">Merkle Proofs</a></strong></li><li><strong><a href="https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033" target="_blank" rel="noreferrer">How is data stored in Ethereum?</a></strong></li><li><strong><a href="https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed" target="_blank" rel="noreferrer">Diving into Ethereum&#39;s world state</a></strong></li><li><strong><a href="https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369" target="_blank" rel="noreferrer">How does Ethereum work anyway?</a></strong></li><li><strong><a href="https://medium.com/coinmonks/a-practical-walkthrough-smart-contract-storage-d3383360ea1b" target="_blank" rel="noreferrer">A (Practical) Walkthrough of Smart Contract Storage</a></strong></li><li><strong><a href="https://medium.com/@codetractio/inside-an-ethereum-transaction-fa94ffca912f" target="_blank" rel="noreferrer">Inside an Ethereum transaction</a></strong></li><li><strong><a href="https://medium.com/blockchannel/life-cycle-of-an-ethereum-transaction-e5c66bae0f6e" target="_blank" rel="noreferrer">Life Cycle of an Ethereum Transaction</a></strong></li><li><strong><a href="https://github.com/ethereum/wiki/wiki/Design-Rationale" target="_blank" rel="noreferrer">Ethereum Design Rationale</a></strong></li></ul>',47),d=[l];function u(g,m,p,f,b,k){return e(),a("div",null,d)}const v=t(h,[["render",u]]);export{y as __pageData,v as default};
